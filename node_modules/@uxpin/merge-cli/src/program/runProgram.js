"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.runProgram = void 0;
const tslib_1 = require("tslib");
const pMapSeries = require("p-map-series");
const getDesignSystemMetadata_1 = require("../steps/serialization/getDesignSystemMetadata");
const tapPromise_1 = require("../utils/promise/tapPromise");
const getProgramArgs_1 = require("./args/getProgramArgs");
const getProjectPaths_1 = require("./args/providers/paths/getProjectPaths");
const Command_1 = require("./command/Command");
const getSteps_1 = require("./command/getSteps");
const getStepsForWatcher_1 = require("./command/getStepsForWatcher");
const setNodeEnv_1 = require("./env/setNodeEnv");
const printCurrentVersion_1 = require("./utils/version/printCurrentVersion");
const setupWatcher_1 = require("./watcher/setupWatcher");
function runProgram(program) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        try {
            setNodeEnv_1.setNodeEnv(process.env.UXPIN_ENV);
            printCurrentVersion_1.printCurrentVersionInfo();
            const programArgs = getProgramArgs_1.getProgramArgs(program);
            yield setupProjectWatcher(programArgs);
            yield runCommand(programArgs);
        }
        catch (error) {
            endWithError(error);
        }
    });
}
exports.runProgram = runProgram;
function runCommand(programArgs) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        yield executeCommandSteps(programArgs, getSteps_1.getSteps(programArgs));
    });
}
function setupProjectWatcher(programArgs) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        if (!isWatchChangesCommand(programArgs)) {
            return;
        }
        yield setupWatcher_1.setupWatcher(programArgs, thunkRunCommandWhenFilesChanged(programArgs));
    });
}
function thunkRunCommandWhenFilesChanged(programArgs) {
    return () => tslib_1.__awaiter(this, void 0, void 0, function* () {
        try {
            yield executeCommandSteps(programArgs, getStepsForWatcher_1.getStepsForWatcher(programArgs));
        }
        catch (error) {
            logError(error);
        }
    });
}
function executeCommandSteps(programArgs, steps) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const stepFunctions = steps
            .filter((step) => step.shouldRun)
            .map((step) => tapPromise_1.tapPromise(step.exec));
        if (shouldPassDesignSystemToCommand(programArgs)) {
            const paths = getProjectPaths_1.getProjectPaths(programArgs);
            const designSystem = yield getDesignSystemMetadata_1.getDesignSystemMetadata(programArgs, paths);
            yield pMapSeries(stepFunctions, (step) => step(designSystem));
        }
        else {
            yield pMapSeries(stepFunctions, (step) => step());
        }
    });
}
function shouldPassDesignSystemToCommand(programArgs) {
    return programArgs.command !== Command_1.Command.GENERATE_PRESETS;
}
function isWatchChangesCommand(programArgs) {
    return programArgs.command === Command_1.Command.EXPERIMENT;
}
function endWithError(error) {
    logError(error);
    process.exit(1);
}
function logError(error) {
    console.error('ERROR:', error instanceof Error ? error.message : error);
}
//# sourceMappingURL=runProgram.js.map