"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.uploadLibrary = void 0;
const tslib_1 = require("tslib");
const path_1 = require("path");
const constants_1 = require("../../../../common/constants");
const createTag_1 = require("../../../../common/services/UXPin/createTag");
const getApiDomain_1 = require("../../../../common/services/UXPin/getApiDomain");
const getLatestCommitHash_1 = require("../../../../common/services/UXPin/getLatestCommitHash");
const postPushMetadata_1 = require("../../../../common/services/UXPin/postPushMetadata");
const postUploadBundle_1 = require("../../../../common/services/UXPin/postUploadBundle");
const updateRepositoryPointerToBranch_1 = require("../../../../common/services/UXPin/updateRepositoryPointerToBranch");
const getConfig_1 = require("../../../../steps/building/config/getConfig");
const isSameVersion_1 = require("../../../../steps/serialization/vcs/isSameVersion");
const getBranchesAtCommit_1 = require("../../../../steps/serialization/vcs/repositories/git/util/getBranchesAtCommit");
const printLine_1 = require("../../../../utils/console/printLine");
const PrintOptions_1 = require("../../../../utils/console/PrintOptions");
function uploadLibrary(buildOptions) {
    return (designSystem) => tslib_1.__awaiter(this, void 0, void 0, function* () {
        const apiDomain = getApiDomain_1.getApiDomain(buildOptions.uxpinApiDomain);
        const authToken = buildOptions.token;
        const vcsDetails = designSystem.result.vcs;
        const commitHash = vcsDetails.commitHash;
        const path = path_1.resolve(buildOptions.uxpinDirPath, getConfig_1.LIBRARY_OUTPUT_FILENAME);
        const branch = vcsDetails && vcsDetails.branchName ? vcsDetails.branchName : constants_1.DEFAULT_BRANCH_NAME;
        const tag = buildOptions.tag;
        // Get the latest commit hash known by the backend
        // NOTE: if the branch has changed locally, but latest commit has not (so a fresh branch)
        // then this will be the same as the current commit hash
        const latestCommitHash = yield getLatestCommitHash_1.getLatestCommitHash(apiDomain, vcsDetails.branchName, authToken);
        // Ensure vcsDetails.paths && branch were provided
        if (!vcsDetails.paths || !branch) {
            printLine_1.printError('üõë Internal Error: VCS Details incomplete');
            return designSystem;
        }
        // Get the branches at the current commit
        const branchesAtCurrentCommit = yield getBranchesAtCommit_1.getBranchesAtCommit(vcsDetails.paths.projectRoot, commitHash);
        // Prevent trying to push non-master commits to master
        if (!branchesAtCurrentCommit.includes(branch)) {
            printLine_1.printError(`üõë The current commit is not on branch [${branch}], please specify --branch to use a custom branch`);
            return designSystem;
        }
        // If the backend already has the commit we're trying to push,
        // Update the repository pointer to the current branch and exit early
        if (isSameVersion_1.isSameVersion(designSystem.result)) {
            printLine_1.printLine('‚úÖ Library is up-to-date!', { color: PrintOptions_1.PrintColor.GREEN });
            // Update the repository pointer to point to the new branch
            yield updateRepositoryPointerWithPrintMessage({
                apiDomain,
                authToken,
                branch,
                commitHash,
            });
            if (tag) {
                yield createTagWithPrintMessage({
                    apiDomain,
                    authToken,
                    commitHash,
                    tag,
                });
            }
            return designSystem;
        }
        let diffSourceCommitHash = null;
        if (vcsDetails.movedObjects && vcsDetails.movedObjects.diffSourceCommitHash) {
            diffSourceCommitHash = vcsDetails.movedObjects.diffSourceCommitHash;
        }
        if (diffSourceCommitHash && diffSourceCommitHash !== latestCommitHash) {
            throw new Error('üõë There was new version deployed during your build. Please try again.');
        }
        try {
            yield postUploadBundle_1.postUploadBundle(apiDomain, authToken, commitHash, path);
            printLine_1.printLine('‚úÖ Library bundle uploaded successfully!', { color: PrintOptions_1.PrintColor.GREEN });
        }
        catch (error) {
            printLine_1.printLine('üõë There was an error while uploading library bundle! Please try again.', { color: PrintOptions_1.PrintColor.RED });
            throw new Error(error.message);
        }
        try {
            yield postPushMetadata_1.postPushMetadata(apiDomain, authToken, designSystem);
            printLine_1.printLine('‚úÖ Library metadata uploaded successfully!', { color: PrintOptions_1.PrintColor.GREEN });
        }
        catch (error) {
            printLine_1.printLine('üõë There was an error while uploading library metadata! Please try again.', { color: PrintOptions_1.PrintColor.RED });
            throw new Error(error.message);
        }
        yield updateRepositoryPointerWithPrintMessage({
            apiDomain,
            authToken,
            branch,
            commitHash,
        });
        if (tag) {
            yield createTagWithPrintMessage({
                apiDomain,
                authToken,
                commitHash,
                tag,
            });
        }
        return designSystem;
    });
}
exports.uploadLibrary = uploadLibrary;
function createTagWithPrintMessage(opts) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        try {
            yield createTag_1.createTag(opts);
            printLine_1.printLine(`üè∑Ô∏è  Library tagged at this point in time with tag [${opts.tag}] at commit hash [${opts.commitHash}]`, { color: PrintOptions_1.PrintColor.YELLOW });
        }
        catch (error) {
            printLine_1.printLine(`üõë There was an error while creating a tag [${opts.tag}] at commit hash [${opts.commitHash}]`, { color: PrintOptions_1.PrintColor.RED });
            throw new Error(error.message);
        }
    });
}
function updateRepositoryPointerWithPrintMessage(opts) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        try {
            // Update the repository pointer to point to the new branch
            yield updateRepositoryPointerToBranch_1.updateRepositoryPointerToBranch(opts);
            printLine_1.printLine(`üõà  Projects using this Design System have been updated to branch [${opts.branch}]`, { color: PrintOptions_1.PrintColor.CYAN });
        }
        catch (error) {
            printLine_1.printLine(`üõë There was an error while updating design system pointers [${opts.branch}]`, { color: PrintOptions_1.PrintColor.RED });
            throw new Error(error.message);
        }
    });
}
//# sourceMappingURL=uploadLibrary.js.map