"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getComponentCategoryPaths = void 0;
const tslib_1 = require("tslib");
const safe = require("colors/safe");
const globby = require("globby");
const lodash_1 = require("lodash");
const p_map_1 = require("p-map");
const util_1 = require("util");
const printLine_1 = require("../../../../../utils/console/printLine");
const sortFilePaths_1 = require("./sortFilePaths");
const NEGATED_PATTERN_MATCH = '!';
function getComponentCategoryPaths(projectRoot, categoryConfig) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        let hasInvalidPatterns = false;
        const patterns = util_1.isArray(categoryConfig.include) ? categoryConfig.include : [categoryConfig.include];
        const positivePatterns = patterns.filter((pattern) => !pattern.startsWith(NEGATED_PATTERN_MATCH));
        // First check if each non negated pattern produces any paths
        const sortedPaths = lodash_1.flatten(yield p_map_1.default(positivePatterns, (pattern) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            let newPaths = yield globby(pattern, { cwd: projectRoot });
            if (newPaths.length === 0) {
                hasInvalidPatterns = true;
                printLine_1.printWarning(`ðŸ‘‰ Pattern ${safe.bold(pattern)} didn't match any files.`);
            }
            // If there are multiple paths returned by globby, sort them
            if (newPaths.length > 1) {
                newPaths = sortFilePaths_1.sortFilePaths(newPaths);
            }
            return newPaths;
        })));
        // If some pattern doesn't provide some files, throw an error as this may result to broken library to be pushed
        // (e.g. when some files won't be commited to the repository)
        if (hasInvalidPatterns) {
            throw new Error(`ðŸš« Please check your config file and fix wrong patterns.`);
        }
        // Finally get paths for all patterns, as this may produce different results than
        // checking each pattern separately (some patterns may be excluded)
        const allPaths = yield globby(patterns, { cwd: projectRoot });
        return lodash_1.intersection(sortedPaths, allPaths);
    });
}
exports.getComponentCategoryPaths = getComponentCategoryPaths;
//# sourceMappingURL=getComponentCategoryPaths.js.map