"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const http_status_codes_1 = require("http-status-codes");
const readFileFromPath_1 = require("../../../../../../utils/fs/readFileFromPath");
const StaticFileHandler_1 = require("../StaticFileHandler");
jest.mock('../../../../../../utils/fs/readFileFromPath');
describe('StaticFileHandler', () => {
    let request;
    let response;
    let filePath;
    let buffer;
    beforeEach(() => {
        request = createFakeRequest();
        response = createFakeResponse();
        filePath = './somePath';
        buffer = new Buffer(0);
        mockFile(filePath, buffer);
    });
    describe('when file exists', () => {
        it('should respond with file content', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            // given
            const handler = new StaticFileHandler_1.StaticFileHandler(filePath);
            // when
            yield handler.handle(request, response);
            // then
            expect(response.end).toHaveBeenCalledWith(buffer, 'utf-8');
        }));
        it('should respond with headers from constructor', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            // given
            const headers = {
                'Access-Control-Allow-Origin': '*',
                'Cache-Control': 'no-cache',
                'Content-Type': 'application/json',
            };
            const handler = new StaticFileHandler_1.StaticFileHandler(filePath, headers);
            // when
            yield handler.handle(request, response);
            // then
            expect(response.writeHead).toHaveBeenCalledWith(http_status_codes_1.OK, headers);
        }));
        it('should respond with specific `Access-Control-Allow-Origin` header', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            // given
            const origin = 'http://some.domain';
            const headers = {
                'Access-Control-Allow-Origin': 'http://some.domain',
                'Cache-Control': 'no-cache',
                'Content-Type': 'application/json',
            };
            const handler = new StaticFileHandler_1.StaticFileHandler(filePath, headers);
            // when
            yield handler.handle(createFakeRequest({ origin }), response);
            // then
            expect(response.writeHead).toHaveBeenCalledWith(http_status_codes_1.OK, headers);
        }));
    });
    describe('when file not exists', () => {
        it('should respond with 404 status code', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            // given
            const handler = new StaticFileHandler_1.StaticFileHandler('not exits');
            // when
            yield handler.handle(request, response);
            // then
            expect(response.writeHead).toHaveBeenCalledWith(http_status_codes_1.NOT_FOUND, { 'Content-Type': 'text/plain' });
        }));
    });
});
function mockFile(filePath, content) {
    (readFileFromPath_1.readFileFromPath.mockImplementation((path) => tslib_1.__awaiter(this, void 0, void 0, function* () {
        if (path === filePath) {
            return content;
        }
        throw new Error('File not found');
    })));
}
function createFakeRequest(headers = {}) {
    return { headers };
}
function createFakeResponse() {
    return {
        end: jest.fn(),
        write: jest.fn(),
        writeHead: jest.fn(),
    };
}
//# sourceMappingURL=StaticFileHandler.test.js.map