"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getBranchesAtCommit = void 0;
const tslib_1 = require("tslib");
const constants_1 = require("../../../../../../common/constants");
const execAsync_1 = require("../../../../../../utils/child_process/execAsync");
const REMOTE_PREFIX_RGX = /^refs\/remotes\/[^\/]+\//;
function getBranchesAtCommit(cwd, fullCommitHash) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const branches = new Set();
        const currentShortHash = fullCommitHash.substring(0, constants_1.SHORT_COMMIT_HASH_IDX);
        const rawReflogOutput = yield execAsync_1.execAsync('git reflog --all', { cwd });
        rawReflogOutput
            .split('\n')
            // Filter out HEAD, the commit in question, and keep only top-level current commits
            .filter((l) => !l.includes('HEAD@') && l.includes('@{0}'))
            // Filter out lines that do not contain
            .filter((l) => l.includes(currentShortHash))
            // Convert the line to a structured object
            .forEach((l) => {
            // tslint:disable-next-line:no-unused-variable
            const [shortCommitHash, ref, ...rest] = l.split(/\s+/);
            const branchName = ref
                .replace('refs/heads/', '')
                // Remotes are left in because some platforms that do detached HEAD checkouts
                // have master present but only as a remote. It's
                .replace(REMOTE_PREFIX_RGX, '')
                .replace('@{0}:', '');
            branches.add(branchName);
        });
        return [...branches];
    });
}
exports.getBranchesAtCommit = getBranchesAtCommit;
//# sourceMappingURL=getBranchesAtCommit.js.map