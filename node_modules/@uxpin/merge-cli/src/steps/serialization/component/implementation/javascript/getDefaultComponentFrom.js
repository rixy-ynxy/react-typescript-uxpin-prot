"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getDefaultComponentFrom = void 0;
const tslib_1 = require("tslib");
const react_docgen_better_proptypes_1 = require("@uxpin/react-docgen-better-proptypes");
const fs_extra_1 = require("fs-extra");
const react_docgen_1 = require("react-docgen");
const CommentTags_1 = require("../../CommentTags");
const hasCommentTag_1 = require("./hasCommentTag");
// tslint:disable-next-line: max-line-length
const parsers = [
    parseWithAnnotation,
    parseDefault,
];
function getDefaultComponentFrom(filePath) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const file = yield fs_extra_1.readFile(filePath, { encoding: 'utf8' });
        let componentDoc;
        let error;
        const handlers = [
            ...react_docgen_1.defaultHandlers,
            react_docgen_better_proptypes_1.importedPropTypesHandler(filePath),
        ];
        // Passing `filename` helps babel to load correct babel configuration file.
        // (NOTE: Without filename option, babel behave as if `babelrc: false` is set)
        // However, react-docgen has a good set of default babel plugins
        // and it has been working for most of customers.
        // I've encountered failure tests from simply setting filename, so,
        // to make sure we are not breaking existing customers integration by this change, we
        // 1. try with react-docgen default babel plugins
        // 2. try with user configured babel config(e.g. .babelrc, babel.config.js)
        const docgenOptions = [
            {
                babelrc: false,
                configFile: false,
                filename: filePath,
            },
            {
                filename: filePath,
            },
        ];
        for (const options of docgenOptions) {
            for (const parser of parsers) {
                try {
                    componentDoc = parser(file, handlers, options);
                }
                catch (e) {
                    error = e;
                }
                if (componentDoc) {
                    return componentDoc;
                }
            }
        }
        if (!componentDoc) {
            throw error || new Error(`Component not found in file: ${filePath}`);
        }
        return componentDoc;
    });
}
exports.getDefaultComponentFrom = getDefaultComponentFrom;
function parseWithAnnotation(file, handlers, options) {
    const parsed = react_docgen_1.parse(file, react_docgen_1.resolver.findAllComponentDefinitions, handlers, options);
    for (const componentDoc of parsed) {
        if (hasCommentTag_1.hasCommentTag(componentDoc.description, CommentTags_1.CommentTags.UXPIN_COMPONENT)) {
            return componentDoc;
        }
    }
}
function parseDefault(file, handlers, options) {
    return react_docgen_1.parse(file, undefined, handlers, options);
}
//# sourceMappingURL=getDefaultComponentFrom.js.map