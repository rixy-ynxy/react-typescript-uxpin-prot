"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isDefaultExported = void 0;
const acorn_loose_1 = require("acorn-loose");
const fs_extra_1 = require("fs-extra");
// This function is checking if component is default exported by
// checking if component is not named exported.
// We are doing this way because there could be multiple components in a single.
// e.g.
// `ButtonDefault` is exported as default, but `ButtonSecondary` is exported as named.
function isDefaultExported(componentPath, name) {
    const content = fs_extra_1.readFileSync(componentPath, { encoding: 'utf8' });
    const ast = acorn_loose_1.parse(content, { sourceType: 'module', ecmaVersion: 2020 });
    if (!ast.body) {
        return false;
    }
    let isNamedExported = false;
    let exportDefaultDeclaration;
    ast.body.forEach((node) => {
        if (node.type === 'ExportDefaultDeclaration') {
            exportDefaultDeclaration = node;
            return;
        }
        if (node.type !== 'ExportNamedDeclaration') {
            return;
        }
        // e.g. export { Component }
        // NOTE: if an export statement is like `export { Component as default }`,
        // the specifier will look like something below
        // Node {
        //   type: 'ExportSpecifier',
        //   start: 11128,
        //   end: 11145,
        //   local: Node {
        //     type: 'Identifier',
        //     start: 11128,
        //     end: 11134,
        //     name: 'Component'
        //   },
        //   exported: Node {
        //     type: 'Identifier',
        //     start: 11138,
        //     end: 11145,
        //     name: 'default'
        //   }
        // },
        // Thus, as long as exported.name === name, it is named exported.
        if (node.declaration === null) {
            isNamedExported = node.specifiers.some((specifier) => {
                return specifier.exported.name === name;
            });
            return;
        }
        // e.g. export class Component
        if (isClassDeclaration(node.declaration)) {
            isNamedExported = node.declaration.id.name === name;
            return;
        }
        // e.g. export function Component
        if (isFunctionDeclaration(node.declaration)) {
            isNamedExported = node.declaration.id.name === name;
            return;
        }
        // e.g. export const Component = ...
        if (isVariableDeclaration(node.declaration)) {
            isNamedExported = node.declaration.declarations.some((variableDeclarator) => {
                return variableDeclarator.id.name === name;
            });
            return;
        }
    });
    // e.g.
    // /**
    //  * @uxpincomponent
    //  */
    // export function Component()|class Component
    // export default HOC(Component);
    if (exportDefaultDeclaration && isCallExpression(exportDefaultDeclaration.declaration)) {
        isNamedExported = !isWrappedWithHOC(name, exportDefaultDeclaration.declaration);
    }
    return !isNamedExported;
}
exports.isDefaultExported = isDefaultExported;
function isClassDeclaration(node) {
    return node.type === 'ClassDeclaration';
}
function isFunctionDeclaration(node) {
    return node.type === 'FunctionDeclaration';
}
function isVariableDeclaration(node) {
    return node.type === 'VariableDeclaration';
}
function isCallExpression(node) {
    return node.type === 'CallExpression';
}
function isWrappedWithHOC(name, expression) {
    if (!expression) {
        return false;
    }
    return expression.arguments && expression.arguments.some((node) => {
        if (isCallExpression(node)) {
            return isWrappedWithHOC(name, node);
        }
        return node.type === 'Identifier' && node.name === name;
    });
}
//# sourceMappingURL=isDefaultExported.js.map