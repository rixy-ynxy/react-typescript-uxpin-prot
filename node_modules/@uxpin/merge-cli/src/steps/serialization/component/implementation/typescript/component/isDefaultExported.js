"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isDefaultExported = void 0;
const ts = require("typescript");
const hasUXPinComponentComment_1 = require("../comments/hasUXPinComponentComment");
const getNodeName_1 = require("../node/getNodeName");
const findExportedFunctionWithReactForwardRef_1 = require("./findExportedFunctionWithReactForwardRef");
const getComponentName_1 = require("./getComponentName");
const isExported_1 = require("./isExported");
function isDefaultExported(declaration, context) {
    const componentName = getComponentName_1.getComponentName(context, declaration);
    // e.g. export default () => {};
    if (ts.isArrowFunction(declaration) && ts.isExportAssignment(declaration.parent)) {
        return true;
    }
    // e.g. export default Class Component
    // e.g. export default function Component()
    // NOTE: This returns `false` for cases like below. So, it is too early to tell
    // if this file export Component as default or not.
    // And it will be checked with `isWrappedWithHOC` at later steps
    // ------------------- Case #1
    // /**
    //  * @uxpincomponent
    //  */
    // export class Button
    // export default withHOC(Component)
    // ------------------- Case #2
    // export function FunctionMatchWithFileName()| export class ClassMatchWithFileName
    // export default withHOC(FunctionMatchWithFileName|ClassMatchWithFileName)
    if (!hasUXPinComponentComment_1.hasUXPinComponentComment(declaration) && hasDefaultKeywordInModifiers(declaration)) {
        return true;
    }
    // export default Component;
    // Because export statement is in different node, we need to go through again...
    let isDefault = false;
    ts.forEachChild(context.file, (node) => {
        // export { Component as default }
        if (ts.isExportDeclaration(node) && node.exportClause && ts.isNamedExports(node.exportClause)) {
            isDefault = node.exportClause.elements.some((specifier) => {
                return (specifier.propertyName &&
                    specifier.propertyName.escapedText === componentName &&
                    specifier.name.escapedText === 'default');
            });
        }
        // isExportAssignment returns true when the code looks like
        // export default Component;
        if (!ts.isExportAssignment(node)) {
            return;
        }
        const exportedName = node.expression.escapedText;
        // const Component = () => {}
        if (isDefaultExportedArrowFunctionWithName(exportedName, componentName, declaration)) {
            isDefault = true;
        }
        // function Component()
        if (isDefaultExportedFunctionWithName(exportedName, declaration)) {
            isDefault = true;
        }
        // class Component
        if (isDefaultExportedClassWithName(exportedName, declaration)) {
            isDefault = true;
        }
        // component wrapped with HOC.
        // export default withHOC(Component);
        if (isWrappedWithHOC(componentName, node.expression)) {
            isDefault = true;
        }
        // export default forwardRef<HTMLBaseElement, Props>((props) => {}
        if (findExportedFunctionWithReactForwardRef_1.isDefaultExportedForwardRef(node)) {
            isDefault = true;
        }
    });
    return isDefault;
}
exports.isDefaultExported = isDefaultExported;
function isDefaultExportedArrowFunctionWithName(exportedName, componentName, declaration) {
    return ts.isArrowFunction(declaration) && exportedName === componentName;
}
function isDefaultExportedFunctionWithName(exportedName, declaration) {
    return ts.isFunctionDeclaration(declaration) && exportedName === getNodeName_1.getNodeName(declaration);
}
function isDefaultExportedClassWithName(exportedName, declaration) {
    return ts.isClassDeclaration(declaration) && exportedName === getNodeName_1.getNodeName(declaration);
}
function isWrappedWithHOC(exportedName, expression) {
    if (!expression) {
        return false;
    }
    // @ts-ignore
    return expression.arguments && expression.arguments.some((node) => {
        if (node.escapedText === exportedName) {
            return true;
        }
        return isWrappedWithHOC(exportedName, node.expression);
    });
}
function hasDefaultKeywordInModifiers(declaration) {
    return (!!declaration.modifiers &&
        isExported_1.isExported(declaration) &&
        declaration.modifiers.some((m) => m.kind === ts.SyntaxKind.DefaultKeyword));
}
//# sourceMappingURL=isDefaultExported.js.map