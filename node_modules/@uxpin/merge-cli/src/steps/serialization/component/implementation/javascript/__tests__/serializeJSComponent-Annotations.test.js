"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const ComponentWrapper_1 = require("../../../wrappers/ComponentWrapper");
const serializeJSComponent_1 = require("../serializeJSComponent");
const getImplementation_1 = require("./utils/getImplementation");
describe('SerializeJSComponent - with annotations', () => {
    describe('function with component declaration', () => {
        let serialized;
        beforeAll(() => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            const component = getImplementation_1.getImplementation('FunctionWithComponentDeclaration');
            serialized = yield serializeJSComponent_1.serializeJSComponent(component);
        }));
        it('returns name of annotated component', () => {
            expect(serialized.result.name).toEqual('FunctionWithComponentDeclarationAndCustomName');
        });
        it('doesnt return namespace value', () => {
            expect(serialized.result.namespace).toBeUndefined();
        });
        it('doesnt return componentDocUrl value', () => {
            expect(serialized.result.componentDocUrl).toBeUndefined();
        });
        it('returns empty list of wrappers', () => {
            expect(serialized.result.wrappers).toEqual([]);
        });
        it('returns props of annotated component', () => {
            expect(serialized.result.properties).toEqual([
                expect.objectContaining({
                    name: 'children',
                }),
                expect.objectContaining({
                    name: 'id',
                }),
                expect.objectContaining({
                    name: 'appearance',
                }),
                expect.objectContaining({
                    name: 'modifier',
                }),
                expect.objectContaining({
                    defaultValue: {
                        value: false,
                    },
                    isRequired: false,
                    name: 'hidden',
                }),
            ]);
        });
        it('returns empty warnings list', () => {
            expect(serialized.warnings).toEqual([]);
        });
    });
    describe('default exported functional component composed with HOC and comment', () => {
        let serialized;
        beforeAll(() => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            const component = getImplementation_1.getImplementation('DefaultExportedFunctionalComponentComposedWithHOCAndComment');
            serialized = yield serializeJSComponent_1.serializeJSComponent(component);
        }));
        it('returns name of annotated component', () => {
            expect(serialized.result.name).toEqual('ClassPrependedWithCommentToBeComposedWithHOC');
        });
        it('returns namespace value of annotated component', () => {
            expect(serialized.result.namespace.name).toEqual('Multi.Level.CustomNamespace');
        });
        it('returns componentDocUrl value of component', () => {
            expect(serialized.result.componentDocUrl).toEqual('https://app.uxpin.com/test');
        });
        it('returns empty list of wrappers', () => {
            expect(serialized.result.wrappers).toEqual([]);
        });
        it('returns props of annotated component', () => {
            expect(serialized.result.properties).toEqual([
                expect.objectContaining({
                    name: 'appearance',
                }),
                expect.objectContaining({
                    name: 'children',
                }),
                expect.objectContaining({
                    name: 'i18n',
                }),
            ]);
        });
        it('returns empty warnings list', () => {
            expect(serialized.warnings).toEqual([]);
        });
    });
    describe('function with namespace declaration', () => {
        let serialized;
        beforeAll(() => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            const component = getImplementation_1.getImplementation('FunctionWithNamespaceDeclaration');
            serialized = yield serializeJSComponent_1.serializeJSComponent(component);
        }));
        it('returns correct component name', () => {
            expect(serialized.result.name).toEqual('FunctionWithNamespaceDeclaration');
        });
        it('returns annotated namespace value', () => {
            expect(serialized.result.namespace.name).toEqual('CustomNamespace');
        });
        it('returns empty list of wrappers', () => {
            expect(serialized.result.wrappers).toEqual([]);
        });
        it('returns correct props list of component', () => {
            expect(serialized.result.properties).toEqual([
                expect.objectContaining({
                    isRequired: true,
                    name: 'name',
                }),
            ]);
        });
        it('returns empty warnings list', () => {
            expect(serialized.warnings).toEqual([]);
        });
    });
    describe('multiple functions without annotation', () => {
        let component;
        beforeAll(() => {
            component = getImplementation_1.getImplementation('MultipleFunctionsWithoutAnnotation');
        });
        it('throws "Multiple exported component definitions" error', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            expect.assertions(1);
            let error = new Error('Error not thrown');
            try {
                yield serializeJSComponent_1.serializeJSComponent(component);
            }
            catch (e) {
                error = e; // standard .toThrow() assertion doesnt work in this case :dunno:
            }
            expect(error.message).toMatch('Multiple exported component definitions found.');
        }));
    });
    describe('function with namespace and wrappers declaration', () => {
        let serialized;
        beforeAll(() => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            const component = getImplementation_1.getImplementation('FunctionWithNamespaceAndWrappersDeclaration');
            serialized = yield serializeJSComponent_1.serializeJSComponent(component);
        }));
        it('returns correct component name', () => {
            expect(serialized.result.name).toEqual('FunctionWithNamespaceAndWrappersDeclaration');
        });
        it('returns annotated namespace value', () => {
            expect(serialized.result.namespace.name).toEqual('CustomNamespace');
        });
        it('returns correct props list of component', () => {
            expect(serialized.result.properties).toEqual([
                expect.objectContaining({
                    isRequired: true,
                    name: 'name',
                }),
            ]);
        });
        it('returns proper list of wrappers', () => {
            expect(serialized.result.wrappers).toEqual([
                {
                    name: ComponentWrapper_1.BuiltInWrappers.NON_RESIZABLE_WRAPPER,
                    type: ComponentWrapper_1.ComponentWrapperType.BUILT_IN,
                },
            ]);
        });
        it('returns empty warnings list', () => {
            expect(serialized.warnings).toEqual([]);
        });
    });
    describe('function with componentDocUrl declaration', () => {
        let serialized;
        beforeAll(() => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            const component = getImplementation_1.getImplementation('FunctionWithDocUrlDeclaration');
            serialized = yield serializeJSComponent_1.serializeJSComponent(component);
        }));
        it('returns correct url', () => {
            expect(serialized.result.componentDocUrl).toEqual('https://app.uxpin.com/test');
        });
        it('returns empty list of wrappers', () => {
            expect(serialized.result.wrappers).toEqual([]);
        });
        it('returns correct props list of component', () => {
            expect(serialized.result.properties).toEqual([
                expect.objectContaining({
                    isRequired: true,
                    name: 'name',
                }),
            ]);
        });
        it('returns empty warnings list', () => {
            expect(serialized.warnings).toEqual([]);
        });
    });
    describe('function with componentDocUrl and wrappers declaration', () => {
        let serialized;
        beforeAll(() => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            const component = getImplementation_1.getImplementation('FunctionWithDocUrlAndWrappersDeclaration');
            serialized = yield serializeJSComponent_1.serializeJSComponent(component);
        }));
        it('returns correct component name', () => {
            expect(serialized.result.name).toEqual('FunctionWithDocUrlAndWrappersDeclaration');
        });
        it('returns annotated componentDocUrl value', () => {
            expect(serialized.result.componentDocUrl).toEqual('https://app.uxpin.com/test');
        });
        it('returns correct props list of component', () => {
            expect(serialized.result.properties).toEqual([
                expect.objectContaining({
                    isRequired: true,
                    name: 'name',
                }),
            ]);
        });
        it('returns proper list of wrappers', () => {
            expect(serialized.result.wrappers).toEqual([
                {
                    name: ComponentWrapper_1.BuiltInWrappers.NON_RESIZABLE_WRAPPER,
                    type: ComponentWrapper_1.ComponentWrapperType.BUILT_IN,
                },
            ]);
        });
        it('returns empty warnings list', () => {
            expect(serialized.warnings).toEqual([]);
        });
    });
    describe('class with bind annotation', () => {
        it('serializes correctly including bind declaration in both function and bound property', () => {
            // given
            const component = getImplementation_1.getImplementation('ClassWithBindAnnotation');
            // when
            return serializeJSComponent_1.serializeJSComponent(component).then((serializedProps) => {
                // then
                const expectedMetadata = {
                    defaultExported: true,
                    name: 'ClassWithBindAnnotation',
                    properties: [
                        {
                            defaultValue: { value: false },
                            description: '',
                            isAutoUpdated: true,
                            isRequired: false,
                            name: 'isChecked',
                            type: { name: 'boolean', structure: {} },
                        },
                        {
                            defaultValue: { value: false },
                            description: '',
                            isAutoUpdated: true,
                            isRequired: false,
                            name: 'isDisabled',
                            type: { name: 'boolean', structure: {} },
                        },
                        {
                            description: '',
                            isRequired: true,
                            name: 'label',
                            type: { name: 'string', structure: {} },
                        },
                        {
                            defaultValue: { value: '' },
                            description: '',
                            isRequired: false,
                            name: 'name',
                            type: { name: 'string', structure: {} },
                        },
                        {
                            autoUpdate: {
                                targetPropName: 'isChecked',
                                valuePath: '0.target.checked',
                            },
                            description: '',
                            isRequired: false,
                            name: 'onChange',
                            type: { name: 'func', structure: {} },
                        },
                        {
                            autoUpdate: {
                                targetPropName: 'isDisabled',
                                valuePath: '0',
                            },
                            description: '',
                            isRequired: false,
                            name: 'onDisabled',
                            type: { name: 'func', structure: {} },
                        },
                    ],
                    wrappers: [],
                };
                expect(serializedProps.result).toEqual(expectedMetadata);
                expect(serializedProps.warnings).toEqual([]);
            });
        });
    });
    describe('class with broken bind annotation', () => {
        it('rejects with an error message', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            // given
            const component = getImplementation_1.getImplementation('ClassWithBrokenBindAnnotation');
            // when
            yield expect(serializeJSComponent_1.serializeJSComponent(component)).rejects.toThrowError(`Incorrect property name pointed as a binding source.
  Expected syntax: @uxpinbind [source property name] [value path - optional].
  Examples:
    @uxpinbind onChange 0.target.checked
    @uxpinbind onSelect`);
        }));
    });
    describe('class with a binding annotation to nonexistent property', () => {
        it('rejects with an error message', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            // given
            const component = getImplementation_1.getImplementation('ClassWithBindAnnotationToNonexistentProp');
            // when
            yield expect(serializeJSComponent_1.serializeJSComponent(component))
                .rejects.toThrowError(`Incorrect property name pointed as a binding source.
      No such property: "onChanged"`);
        }));
    });
    describe('class with overlapping bind annotations', () => {
        it('rejects with an error message', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            // given
            const component = getImplementation_1.getImplementation('ClassWithOverlappingBindAnnotations');
            // when
            yield expect(serializeJSComponent_1.serializeJSComponent(component))
                .rejects.toThrowError(`More than one property is trying to bind the same source property "onChange"`);
        }));
    });
});
//# sourceMappingURL=serializeJSComponent-Annotations.test.js.map