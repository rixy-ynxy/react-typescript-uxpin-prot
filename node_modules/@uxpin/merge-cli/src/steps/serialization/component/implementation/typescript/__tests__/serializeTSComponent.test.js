"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getImplementation = void 0;
const tslib_1 = require("tslib");
const getExampleComponentPath_1 = require("../../../../../../../test/utils/resources/getExampleComponentPath");
const serializeTSComponent_1 = require("../serializeTSComponent");
describe('serializeTSComponent', () => {
    describe('providing array of objects describing all properties of the TypeScript component', () => {
        it('serializes functional component with primitive property types', () => {
            // given
            const component = getImplementation('FunctionPrimitivesOnly');
            const expectedMetadata = {
                defaultExported: true,
                name: 'FunctionPrimitivesOnly',
                properties: [
                    {
                        description: '',
                        isRequired: false,
                        name: 'children',
                        type: { name: 'string', structure: {} },
                    },
                    {
                        description: '',
                        isRequired: true,
                        name: 'id',
                        type: { name: 'string', structure: {} },
                    },
                    {
                        description: '',
                        isRequired: false,
                        name: 'action',
                        type: { name: 'number', structure: {} },
                    },
                    {
                        description: '',
                        isRequired: false,
                        name: 'hidden',
                        type: { name: 'boolean', structure: {} },
                    },
                ],
                wrappers: [],
            };
            // when
            return serializeTSComponent_1.serializeTSComponent(component).then((serializedProps) => {
                // then
                expect(serializedProps.result).toEqual(expectedMetadata);
                expect(serializedProps.warnings).toEqual([]);
            });
        });
        it('serializes class component with date property ', () => {
            // given
            const component = getImplementation('ClassWithDateType');
            const expectedMetadata = {
                componentDocUrl: undefined,
                defaultExported: true,
                name: 'ClassWithDateType',
                namespace: undefined,
                properties: [
                    {
                        defaultValue: {
                            value: '2016-07-19T20:23:01.804Z',
                        },
                        description: 'Dates only',
                        isRequired: true,
                        name: 'dateInteger',
                        type: {
                            name: 'date',
                            structure: {},
                        },
                    },
                    {
                        defaultValue: {
                            value: '2010-08-08T00:00:00.000Z',
                        },
                        description: '',
                        isRequired: true,
                        name: 'dateString',
                        type: {
                            name: 'date',
                            structure: {},
                        },
                    },
                    {
                        defaultValue: {
                            value: '1997-02-01T01:01:01.001Z',
                        },
                        description: '',
                        isRequired: true,
                        name: 'dateRest',
                        type: {
                            name: 'date',
                            structure: {},
                        },
                    },
                ],
                wrappers: [],
            };
            // when
            return serializeTSComponent_1.serializeTSComponent(component).then((serializedProps) => {
                // then
                expect(serializedProps.result).toEqual(expectedMetadata);
                expect(serializedProps.warnings).toEqual([]);
            });
        });
        it('serializes class component with empty date property ', () => {
            // given
            const component = getImplementation('ClassWithEmptyDateType');
            // when
            return serializeTSComponent_1.serializeTSComponent(component).then((serializedProps) => {
                // then
                expect(serializedProps.result).toEqual(expect.objectContaining({
                    name: expect.any(String),
                    properties: expect.arrayContaining([
                        expect.objectContaining({
                            defaultValue: expect.objectContaining({
                                value: expect.any(String),
                            }),
                        }),
                    ]),
                    wrappers: expect.any(Array),
                }));
                expect(serializedProps.warnings).toEqual([]);
            });
        });
        it('serializes class component with enum property types', () => {
            // given
            const component = getImplementation('ClassEnumTypes');
            const expectedMetadata = {
                defaultExported: true,
                name: 'ClassEnumTypes',
                properties: [
                    {
                        description: 'String only',
                        isRequired: false,
                        name: 'children',
                        type: { name: 'string', structure: {} },
                    },
                    {
                        description: '',
                        isRequired: true,
                        name: 'appearance',
                        type: {
                            name: 'union',
                            structure: {
                                elements: expect.arrayContaining([
                                    { name: 'literal', structure: { value: 'secondary' } },
                                    { name: 'literal', structure: { value: 'primary' } },
                                    { name: 'literal', structure: { value: 'link' } },
                                ]),
                            },
                        },
                    },
                    {
                        description: '',
                        isRequired: false,
                        name: 'size',
                        type: {
                            name: 'union',
                            structure: {
                                elements: [
                                    { name: 'enum', structure: { label: 'Large', value: 'large' } },
                                    { name: 'enum', structure: { label: 'Medium', value: 'medium' } },
                                    { name: 'enum', structure: { label: 'Small', value: 'small' } },
                                ],
                            },
                        },
                    },
                    {
                        defaultValue: {
                            value: 1,
                        },
                        description: '',
                        isRequired: true,
                        name: 'propNumeric',
                        type: {
                            name: 'union',
                            structure: {
                                elements: [
                                    { name: 'enum', structure: { label: 'Zero', value: 0 } },
                                    { name: 'enum', structure: { label: 'One', value: 1 } },
                                ],
                            },
                        },
                    },
                    {
                        description: '',
                        isRequired: true,
                        name: 'propCustomNumeric',
                        type: {
                            name: 'union',
                            structure: {
                                elements: [
                                    { name: 'enum', structure: { label: 'Blue', value: 3 } },
                                    { name: 'enum', structure: { label: 'Red', value: 4 } },
                                    { name: 'enum', structure: { label: 'Green', value: 5 } },
                                ],
                            },
                        },
                    },
                    {
                        description: '',
                        isRequired: true,
                        name: 'propComputed',
                        type: {
                            name: 'unsupported',
                            structure: { raw: 'enum' }
                        },
                    },
                    {
                        defaultValue: {
                            value: 0,
                        },
                        description: '',
                        isRequired: true,
                        name: 'propHeterogeneous',
                        type: {
                            name: 'union',
                            structure: {
                                elements: [
                                    { name: 'enum', structure: { label: 'No', value: 0 } },
                                    { name: 'enum', structure: { label: 'Yes', value: 'YES' } },
                                ],
                            },
                        },
                    },
                ],
                wrappers: [],
            };
            // when
            return serializeTSComponent_1.serializeTSComponent(component).then((serializedProps) => {
                // then
                expect(serializedProps.result).toEqual(expectedMetadata);
                expect(serializedProps.warnings).toEqual([]);
            });
        });
        it('serializes class component with default property values', () => {
            // given
            const component = getImplementation('ClassWithDefaults');
            const expectedMetadata = {
                defaultExported: true,
                name: 'ClassWithDefaults',
                properties: [
                    {
                        defaultValue: { value: 'Submit' },
                        description: '',
                        isRequired: false,
                        name: 'value',
                        type: { name: 'string', structure: {} },
                    },
                    {
                        defaultValue: { value: 'secondary' },
                        description: '',
                        isRequired: true,
                        name: 'appearance',
                        type: {
                            name: 'union',
                            structure: {
                                elements: expect.arrayContaining([
                                    { name: 'literal', structure: { value: 'secondary' } },
                                    { name: 'literal', structure: { value: 'primary' } },
                                    { name: 'literal', structure: { value: 'link' } },
                                ]),
                            },
                        },
                    },
                    {
                        defaultValue: { value: 1223 },
                        description: 'Default value from JSDoc comment is overridden by value from `defaultProps`',
                        isRequired: true,
                        name: 'width',
                        type: { name: 'number', structure: {} },
                    },
                    {
                        defaultValue: { value: 233 },
                        description: 'Number default value from JSDoc',
                        isRequired: true,
                        name: 'height',
                        type: { name: 'number', structure: {} },
                    },
                    {
                        defaultValue: { value: true },
                        description: '',
                        isRequired: true,
                        name: 'isOpen',
                        type: { name: 'boolean', structure: {} },
                    },
                    {
                        defaultValue: { value: { name: 'Untitled' } },
                        description: 'Object JSDoc default value',
                        isRequired: false,
                        name: 'item',
                        type: { name: 'shape', structure: {} },
                    },
                    {
                        defaultValue: { value: false },
                        description: '',
                        isRequired: true,
                        name: 'isDisabled',
                        type: { name: 'boolean', structure: {} },
                    },
                    {
                        defaultValue: { value: 'JSDoc default value' },
                        description: '',
                        isRequired: true,
                        name: 'otherValue',
                        type: { name: 'string', structure: {} },
                    },
                    {
                        defaultValue: { value: 'JSDoc default value double quoted' },
                        description: '',
                        isRequired: true,
                        name: 'yetAnotherValue',
                        type: { name: 'string', structure: {} },
                    },
                ],
                wrappers: [],
            };
            // when
            return serializeTSComponent_1.serializeTSComponent(component).then((serializedProps) => {
                // then
                expect(serializedProps.result).toEqual(expectedMetadata);
                expect(serializedProps.warnings).toEqual([]);
            });
        });
        it('serializes component with interface property type', () => {
            // given
            const component = getImplementation('ClassInterfaceTypes');
            const expectedMetadata = {
                defaultExported: true,
                name: 'ClassInterfaceTypes',
                properties: [
                    {
                        description: '',
                        isRequired: true,
                        name: 'item',
                        type: { name: 'shape', structure: {} },
                    },
                ],
                wrappers: [],
            };
            // when
            return serializeTSComponent_1.serializeTSComponent(component).then((serializedProps) => {
                // then
                expect(serializedProps.result).toEqual(expectedMetadata);
                expect(serializedProps.warnings).toEqual([]);
            });
        });
        it('serializes component with imported interface property type', () => {
            // given
            const component = getImplementation('FunctionWithImportedTypes');
            const expectedMetadata = {
                defaultExported: true,
                name: 'FunctionWithImportedTypes',
                properties: [
                    {
                        description: '',
                        isRequired: false,
                        name: 'children',
                        type: { name: 'string', structure: {} },
                    },
                    {
                        description: '',
                        isRequired: true,
                        name: 'item',
                        type: { name: 'shape', structure: {} },
                    },
                ],
                wrappers: [],
            };
            // when
            return serializeTSComponent_1.serializeTSComponent(component).then((serializedProps) => {
                // then
                expect(serializedProps.result).toEqual(expectedMetadata);
                expect(serializedProps.warnings).toEqual([]);
            });
        });
        it('serializes component with imported type of properties object', () => {
            // given
            const component = getImplementation('ClassWithImportedPropertiesType');
            const expectedMetadata = {
                defaultExported: true,
                name: 'ClassWithImportedPropertiesType',
                properties: [
                    {
                        description: '',
                        isRequired: true,
                        name: 'name',
                        type: { name: 'string', structure: {} },
                    },
                    {
                        description: '',
                        isRequired: true,
                        name: 'value',
                        type: { name: 'number', structure: {} },
                    },
                    {
                        description: '',
                        isRequired: true,
                        name: 'nested',
                        type: { name: 'shape', structure: {} },
                    },
                ],
                wrappers: [],
            };
            // when
            return serializeTSComponent_1.serializeTSComponent(component).then((serializedProps) => {
                // then
                expect(serializedProps.result).toEqual(expectedMetadata);
                expect(serializedProps.warnings).toEqual([]);
            });
        });
        it('serializes component with function property types', () => {
            // given
            const component = getImplementation('ClassWithFunctionTypes');
            const expectedMetadata = {
                defaultExported: true,
                name: 'ClassWithFunctionTypes',
                properties: [
                    {
                        description: '',
                        isRequired: true,
                        name: 'value',
                        type: { name: 'string', structure: {} },
                    },
                    {
                        description: 'Inline function type',
                        isRequired: false,
                        name: 'onClick',
                        type: { name: 'func', structure: {} },
                    },
                    {
                        description: 'Type alias reference',
                        isRequired: false,
                        name: 'onOpen',
                        type: { name: 'func', structure: {} },
                    },
                    {
                        description: 'Method signature',
                        isRequired: true,
                        name: 'onResize',
                        type: { name: 'func', structure: {} },
                    },
                    {
                        description: 'Optional method signature',
                        isRequired: false,
                        name: 'onMouseEnter',
                        type: { name: 'func', structure: {} },
                    },
                ],
                wrappers: [],
            };
            // when
            return serializeTSComponent_1.serializeTSComponent(component).then((serializedProps) => {
                // then
                expect(serializedProps.result).toEqual(expectedMetadata);
                expect(serializedProps.warnings).toEqual([]);
            });
        });
        it('serializes component with combined type of properties object', () => {
            // given
            const component = getImplementation('ClassWithCombinedPropertiesType');
            const expectedMetadata = {
                defaultExported: true,
                name: 'ClassWithCombinedPropertiesType',
                properties: [
                    {
                        description: '',
                        isRequired: true,
                        name: 'name',
                        type: { name: 'string', structure: {} },
                    },
                    {
                        description: '',
                        isRequired: true,
                        name: 'value',
                        type: { name: 'number', structure: {} },
                    },
                    {
                        description: '',
                        isRequired: true,
                        name: 'nested',
                        type: { name: 'shape', structure: {} },
                    },
                    {
                        description: 'Local property',
                        isRequired: true,
                        name: 'id',
                        type: { name: 'string', structure: {} },
                    },
                ],
                wrappers: [],
            };
            // when
            return serializeTSComponent_1.serializeTSComponent(component).then((serializedProps) => {
                // then
                expect(serializedProps.result).toEqual(expectedMetadata);
                expect(serializedProps.warnings).toEqual([]);
            });
        });
        it('serializes component with extended type of properties object', () => {
            // given
            const component = getImplementation('FunctionWithExtendedPropertiesType');
            const expectedMetadata = {
                defaultExported: true,
                name: 'FunctionWithExtendedPropertiesType',
                properties: [
                    {
                        description: '',
                        isRequired: false,
                        name: 'children',
                        type: { name: 'string', structure: {} },
                    },
                    {
                        description: 'Documentation of inherited property',
                        isRequired: false,
                        name: 'action',
                        type: { name: 'number', structure: {} },
                    },
                    {
                        description: '',
                        isRequired: false,
                        name: 'hidden',
                        type: { name: 'boolean', structure: {} },
                    },
                    {
                        description: '',
                        isRequired: true,
                        name: 'id',
                        type: { name: 'string', structure: {} },
                    },
                ],
                wrappers: [],
            };
            // when
            return serializeTSComponent_1.serializeTSComponent(component).then((serializedProps) => {
                // then
                expect(serializedProps.result).toEqual(expectedMetadata);
                expect(serializedProps.warnings).toEqual([]);
            });
        });
        // @todo #20211: Support for arrow function component with static default props
        it.skip('serializes arrow function component with defaults declared as static property', () => {
            // given
            const component = getImplementation('ArrowFunctionWithDefaultsAsStaticProperty');
            const expectedMetadata = {
                defaultExported: true,
                name: 'ArrowFunctionWithDefaultsAsStaticProperty',
                properties: [
                    {
                        description: '',
                        isRequired: false,
                        name: 'children',
                        type: { name: 'node', structure: {} },
                    },
                    {
                        description: '',
                        isRequired: true,
                        name: 'id',
                        type: { name: 'string', structure: {} },
                    },
                    {
                        description: '',
                        isRequired: true,
                        name: 'appearance',
                        type: { name: 'string', structure: {} },
                    },
                    {
                        defaultValue: { value: 'neutral' },
                        description: '',
                        isRequired: false,
                        name: 'modifier',
                        type: { name: 'string', structure: {} },
                    },
                    {
                        defaultValue: { value: false },
                        description: '',
                        isRequired: false,
                        name: 'hidden',
                        type: { name: 'boolean', structure: {} },
                    },
                ],
                wrappers: [],
            };
            // when
            return serializeTSComponent_1.serializeTSComponent(component).then((serializedProps) => {
                // then
                expect(serializedProps.result).toEqual(expectedMetadata);
                expect(serializedProps.warnings).toEqual([]);
            });
        });
        it('serializes default-exported arrow function with defaults declared in destructuring assignment', () => {
            // given
            const component = getImplementation('DefaultExportedArrowFunctionWithDefaultsInDestructuring');
            const expectedMetadata = {
                defaultExported: true,
                name: 'DefaultExportedArrowFunctionWithDefaultsInDestructuring',
                properties: [
                    {
                        description: '',
                        isRequired: false,
                        name: 'children',
                        type: { name: 'node', structure: {} },
                    },
                    {
                        defaultValue: { value: 'neutral' },
                        description: '',
                        isRequired: false,
                        name: 'modifier',
                        type: { name: 'string', structure: {} },
                    },
                    {
                        defaultValue: { value: false },
                        description: '',
                        isRequired: true,
                        name: 'hidden',
                        type: { name: 'boolean', structure: {} },
                    },
                ],
                wrappers: [],
            };
            // when
            return serializeTSComponent_1.serializeTSComponent(component).then((serializedProps) => {
                // then
                expect(serializedProps.result).toEqual(expectedMetadata);
                expect(serializedProps.warnings).toEqual([]);
            });
        });
        it('serializes functional component with defaults declared in destructuring assignment', () => {
            // given
            const component = getImplementation('FunctionWithDefaultsInDestructuring');
            const expectedMetadata = {
                defaultExported: true,
                name: 'FunctionWithDefaultsInDestructuring',
                properties: [
                    {
                        description: '',
                        isRequired: false,
                        name: 'children',
                        type: { name: 'node', structure: {} },
                    },
                    {
                        description: '',
                        isRequired: true,
                        name: 'id',
                        type: { name: 'string', structure: {} },
                    },
                    {
                        description: '',
                        isRequired: true,
                        name: 'appearance',
                        type: { name: 'string', structure: {} },
                    },
                    {
                        defaultValue: { value: 'neutral' },
                        description: '',
                        isRequired: false,
                        name: 'modifier',
                        type: { name: 'string', structure: {} },
                    },
                    {
                        defaultValue: { value: false },
                        description: '',
                        isRequired: true,
                        name: 'hidden',
                        type: { name: 'boolean', structure: {} },
                    },
                ],
                wrappers: [],
            };
            // when
            return serializeTSComponent_1.serializeTSComponent(component).then((serializedProps) => {
                // then
                expect(serializedProps.result).toEqual(expectedMetadata);
                expect(serializedProps.warnings).toEqual([]);
            });
        });
        it('serializes component props with index type', () => {
            // given
            const component = getImplementation('ClassWithIndexedType');
            const expectedMetadata = {
                defaultExported: true,
                name: 'ClassWithIndexedType',
                properties: [
                    {
                        description: '',
                        isRequired: true,
                        name: 'propLocal',
                        type: { name: 'string', structure: {} },
                    },
                    {
                        description: '',
                        isRequired: true,
                        name: 'propAliasShape',
                        type: { name: 'shape', structure: {} },
                    },
                    {
                        description: '',
                        isRequired: true,
                        name: 'propAliasNumber',
                        type: { name: 'number', structure: {} },
                    },
                ],
                wrappers: [],
            };
            // when
            return serializeTSComponent_1.serializeTSComponent(component).then((serializedProps) => {
                // then
                expect(serializedProps.result).toEqual(expectedMetadata);
                expect(serializedProps.warnings).toEqual([]);
            });
        });
        it('serializes component props with extended interface type', () => {
            // given
            const component = getImplementation('ClassWithExtendedInterface');
            const expectedMetadata = {
                defaultExported: true,
                name: 'ClassWithExtendedInterface',
                properties: [
                    {
                        description: '',
                        isRequired: false,
                        name: 'helpText',
                        type: { name: 'string', structure: {} },
                    },
                    {
                        description: '',
                        isRequired: true,
                        name: 'image',
                        type: { name: 'string', structure: {} },
                    },
                    {
                        description: '',
                        isRequired: true,
                        name: 'iconType',
                        type: { name: 'string', structure: {} },
                    },
                    {
                        description: '',
                        isRequired: true,
                        name: 'size',
                        type: { name: 'number', structure: {} },
                    },
                    {
                        description: '',
                        isRequired: false,
                        name: 'disabled',
                        type: { name: 'boolean', structure: {} },
                    },
                    {
                        description: '',
                        isRequired: true,
                        name: 'actionType',
                        type: { name: 'string', structure: {} },
                    },
                ],
                wrappers: [],
            };
            // when
            return serializeTSComponent_1.serializeTSComponent(component).then((serializedProps) => {
                // then
                expect(serializedProps.result).toEqual(expectedMetadata);
                expect(serializedProps.warnings).toEqual([]);
            });
        });
        it('serializes functional component with intersection type of properties object', () => {
            // given
            const component = getImplementation('FunctionWithCombinedPropertiesType');
            const expectedMetadata = {
                defaultExported: true,
                name: 'FunctionWithCombinedPropertiesType',
                properties: [
                    {
                        description: 'Local property',
                        isRequired: true,
                        name: 'id',
                        type: { name: 'string', structure: {} },
                    },
                    {
                        description: '',
                        isRequired: true,
                        name: 'hidden',
                        type: { name: 'boolean', structure: {} },
                    },
                    {
                        description: '',
                        isRequired: false,
                        name: 'children',
                        type: { name: 'string', structure: {} },
                    },
                    {
                        description: '',
                        isRequired: true,
                        name: 'name',
                        type: { name: 'string', structure: {} },
                    },
                    {
                        description: '',
                        isRequired: true,
                        name: 'value',
                        type: { name: 'number', structure: {} },
                    },
                    {
                        description: '',
                        isRequired: true,
                        name: 'nested',
                        type: { name: 'shape', structure: {} },
                    },
                ],
                wrappers: [],
            };
            // when
            return serializeTSComponent_1.serializeTSComponent(component).then((serializedProps) => {
                // then
                expect(serializedProps.result).toEqual(expectedMetadata);
                expect(serializedProps.warnings).toEqual([]);
            });
        });
        it('serializes functional component with intersection and union type of properties object', () => {
            // given
            const component = getImplementation('FunctionWithCombinedUnionPropertiesType');
            const expectedMetadata = {
                defaultExported: true,
                name: 'FunctionWithCombinedUnionPropertiesType',
                properties: [
                    {
                        description: 'Local property',
                        isRequired: true,
                        name: 'id',
                        type: { name: 'string', structure: {} },
                    },
                    {
                        description: '',
                        isRequired: false,
                        name: 'disabled',
                        type: { name: 'boolean', structure: {} },
                    },
                    {
                        description: '',
                        isRequired: true,
                        name: 'i18n',
                        type: { name: 'string', structure: {} },
                    },
                    {
                        description: '',
                        isRequired: false,
                        name: 'readOnly',
                        type: { name: 'boolean', structure: {} },
                    },
                    {
                        description: '',
                        isRequired: false,
                        name: 'onChange',
                        type: { name: 'func', structure: {} },
                    },
                ],
                wrappers: [],
            };
            // when
            return serializeTSComponent_1.serializeTSComponent(component).then((serializedProps) => {
                // then
                expect(serializedProps.result).toEqual(expectedMetadata);
                expect(serializedProps.warnings).toEqual([]);
            });
        });
        it('serializes functional component with property with intersection type', () => {
            // given
            const component = getImplementation('FunctionWithCombinedProperty');
            const expectedMetadata = {
                defaultExported: true,
                name: 'FunctionWithCombinedProperty',
                properties: [
                    {
                        description: 'Local property',
                        isRequired: true,
                        name: 'id',
                        type: { name: 'string', structure: {} },
                    },
                    {
                        description: '',
                        isRequired: true,
                        name: 'user',
                        type: { name: 'shape', structure: {} },
                    },
                ],
                wrappers: [],
            };
            // when
            return serializeTSComponent_1.serializeTSComponent(component).then((serializedProps) => {
                // then
                expect(serializedProps.result).toEqual(expectedMetadata);
                expect(serializedProps.warnings).toEqual([]);
            });
        });
        it('serializes component props imported from shorthanded file ' +
            'exporting directly from import from index file', () => {
            // given
            const component = getImplementation('ClassWithTypeImportedFromIndexFileExportingFromImport');
            const expectedMetadata = {
                defaultExported: true,
                name: 'ClassWithTypeImportedFromIndexFileExportingFromImport',
                properties: [
                    {
                        description: '',
                        isRequired: true,
                        name: 'propLocal',
                        type: {
                            name: 'shape',
                            structure: {},
                        },
                    },
                ],
                wrappers: [],
            };
            // when
            return serializeTSComponent_1.serializeTSComponent(component).then((serializedProps) => {
                // then
                expect(serializedProps.result).toEqual(expectedMetadata);
                expect(serializedProps.warnings).toEqual([]);
            });
        });
        it('serializes component props with union type in type alias', () => {
            // given
            const component = getImplementation('ClassWithUnionTypeInAliasType');
            const expectedMetadata = {
                defaultExported: true,
                name: 'ClassWithUnionTypeInAliasType',
                properties: [
                    {
                        description: '',
                        isRequired: true,
                        name: 'aliasedUnionProp',
                        type: {
                            name: 'union',
                            structure: {
                                elements: expect.arrayContaining([
                                    { name: 'literal', structure: { value: 'slim' } },
                                    { name: 'literal', structure: { value: 'medium' } },
                                    { name: 'literal', structure: { value: 'large' } },
                                ]),
                            },
                        },
                    },
                    {
                        description: '',
                        isRequired: true,
                        name: 'nestedUnionProp',
                        type: {
                            name: 'union',
                            structure: {
                                elements: expect.arrayContaining([
                                    { name: 'literal', structure: { value: 'some' } },
                                    { name: 'literal', structure: { value: 1 } },
                                    { name: 'literal', structure: { value: 'slim' } },
                                    { name: 'literal', structure: { value: 'medium' } },
                                    { name: 'literal', structure: { value: 'large' } },
                                ]),
                            },
                        },
                    },
                ],
                wrappers: [],
            };
            // when
            return serializeTSComponent_1.serializeTSComponent(component).then((serializedProps) => {
                // then
                expect(serializedProps.result).toEqual(expectedMetadata);
                expect(serializedProps.warnings).toEqual([]);
            });
        });
        it('serializes component props with typeof/keyof operators', () => {
            // given
            const component = getImplementation('ClassWithKeyOfTypeOfOperatorInType');
            const expectedMetadata = {
                defaultExported: true,
                name: 'ClassWithKeyOfTypeOfOperatorInType',
                properties: [
                    {
                        description: '',
                        isRequired: true,
                        name: 'typeOfProp',
                        type: { name: 'number', structure: {} },
                    },
                    {
                        description: '',
                        isRequired: true,
                        name: 'keyOfProp',
                        type: { name: 'union',
                            structure: {
                                elements: [
                                    { name: 'literal', structure: { value: 'name' } },
                                    { name: 'literal', structure: { value: 'value' } },
                                    { name: 'literal', structure: { value: 'nested' } },
                                ],
                            },
                        },
                    },
                    {
                        description: '',
                        isRequired: true,
                        name: 'keyOfTypeOfProp',
                        type: { name: 'union',
                            structure: {
                                elements: [
                                    { name: 'literal', structure: { value: 'name' } },
                                    { name: 'literal', structure: { value: 'value' } },
                                    { name: 'literal', structure: { value: 'nested' } },
                                ],
                            },
                        },
                    },
                ],
                wrappers: [],
            };
            // when
            return serializeTSComponent_1.serializeTSComponent(component).then((serializedProps) => {
                // then
                expect(serializedProps.result).toEqual(expectedMetadata);
                expect(serializedProps.warnings).toEqual([]);
            });
        });
        it('serializes component props with array of union type', () => {
            // given
            const component = getImplementation('ClassWithArrayOfUnionType');
            const expectedMetadata = {
                defaultExported: true,
                name: 'ClassWithArrayOfUnionType',
                properties: [
                    {
                        description: '',
                        isRequired: true,
                        name: 'propWithArrayOfUnion',
                        type: {
                            name: 'union',
                            structure: {
                                elements: expect.arrayContaining([
                                    { name: 'string', structure: {} },
                                    { name: 'element', structure: {} },
                                    { name: 'array', structure: {} },
                                ]),
                            },
                        },
                    },
                ],
                wrappers: [],
            };
            // when
            return serializeTSComponent_1.serializeTSComponent(component).then((serializedProps) => {
                // then
                expect(serializedProps.result).toEqual(expectedMetadata);
                expect(serializedProps.warnings).toEqual([]);
            });
        });
        it('serializes component props with two dimensional array', () => {
            // given
            const component = getImplementation('ClassWithTwoDimensionalArray');
            const expectedMetadata = {
                defaultExported: true,
                name: 'ClassWithTwoDimensionalArray',
                properties: [
                    {
                        description: '',
                        isRequired: true,
                        name: 'rows',
                        type: {
                            name: 'array',
                            structure: {},
                        },
                    },
                ],
                wrappers: [],
            };
            // when
            return serializeTSComponent_1.serializeTSComponent(component).then((serializedProps) => {
                // then
                expect(serializedProps.result).toEqual(expectedMetadata);
                expect(serializedProps.warnings).toEqual([]);
            });
        });
        it('doesn\'t support imported Component type in other way than `React.Component`', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            // given
            const component = getImplementation('ClassWithoutImportedReactComponent');
            // when
            yield expect(serializeTSComponent_1.serializeTSComponent(component)).rejects.toThrowError('No component properties found');
        }));
        it('rejects returned promise when there is no React component in the given file', (done) => {
            // given
            const component = getImplementation('FileWithoutComponent');
            // when
            serializeTSComponent_1.serializeTSComponent(component).catch((error) => {
                // then
                expect(error.message).toMatch(/No .*component .*found/i);
                done();
            });
        });
        it('rejects returned promise when there is no file at the given path', (done) => {
            // given
            const component = getImplementation('NonexistentFile');
            // when
            serializeTSComponent_1.serializeTSComponent(component).catch(() => {
                // then
                done();
            });
        });
        describe('file with default exported component composed with HOC is given', () => {
            const getI18nComponentMetadata = (expectedName) => {
                return {
                    defaultExported: true,
                    name: expectedName,
                    properties: [
                        {
                            description: '',
                            isRequired: true,
                            name: 'appearance',
                            type: {
                                name: 'union',
                                structure: {
                                    elements: [
                                        { name: 'literal', structure: { value: 'secondary' } },
                                        { name: 'literal', structure: { value: 'primary' } },
                                        { name: 'literal', structure: { value: 'link' } },
                                    ],
                                },
                            },
                        },
                        {
                            description: '',
                            isRequired: false,
                            name: 'children',
                            type: { name: 'string', structure: {} },
                        },
                        {
                            description: '',
                            isRequired: true,
                            name: 'i18n',
                            type: { name: 'string', structure: {} },
                        },
                    ],
                    wrappers: [],
                };
            };
            it('serializes class component specified by a comment', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
                // when
                const expectedMetadata = getI18nComponentMetadata('ClassPrependedWithCommentToBeComposedWithHOC');
                // given
                const component = getImplementation('DefaultExportedClassComposedWithHOCAndComment');
                // when
                const serializedProps = yield serializeTSComponent_1.serializeTSComponent(component);
                // then
                expect(serializedProps.warnings).toEqual([]);
                expect(serializedProps.result).toEqual(expectedMetadata);
            }));
            it('serializes functional component specified by a comment', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
                // when
                const expectedMetadata = getI18nComponentMetadata('FunctionalComponentPrependedWithCommentToBeComposedWithHOC');
                // given
                const component = getImplementation('DefaultExportedFunctionalComponentComposedWithHOCAndComment');
                // when
                const serializedProps = yield serializeTSComponent_1.serializeTSComponent(component);
                // then
                expect(serializedProps.warnings).toEqual([]);
                expect(serializedProps.result).toEqual(expectedMetadata);
            }));
            it('serializes class component matching file name', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
                // when
                const expectedMetadata = getI18nComponentMetadata('DefaultExportedClassMatchingFilenameComposedWithHOC');
                const component = getImplementation('DefaultExportedClassMatchingFilenameComposedWithHOC');
                // when
                const serializedProps = yield serializeTSComponent_1.serializeTSComponent(component);
                // then
                expect(serializedProps.warnings).toEqual([]);
                expect(serializedProps.result).toEqual(expectedMetadata);
            }));
            it('serializes functional component matching file name', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
                // when
                const expectedMetadata = getI18nComponentMetadata('DefaultExportedFunctionalComponentMatchingFilenameComposedWithHOC');
                const component = getImplementation('DefaultExportedFunctionalComponentMatchingFilenameComposedWithHOC');
                // when
                const serializedProps = yield serializeTSComponent_1.serializeTSComponent(component);
                // then
                expect(serializedProps.warnings).toEqual([]);
                expect(serializedProps.result).toEqual(expectedMetadata);
            }));
        });
        it('serializes component with custom description, name and ignore', () => {
            // given
            const component = getImplementation('ClassWithPropTypesWithComments');
            const expectedMetadata = {
                defaultExported: true,
                name: 'ClassWithPropTypesWithComments',
                properties: [
                    {
                        customDescription: `Multiline
description
of
the
component.`,
                        customName: 'type',
                        description: '',
                        isRequired: true,
                        name: 'buttonType',
                        type: {
                            name: 'string',
                            structure: {},
                        },
                    },
                    {
                        customDescription: 'Custom description',
                        customName: 'disabled',
                        description: 'This is description of isDisabled property',
                        hidden: true,
                        isRequired: true,
                        name: 'isDisabled',
                        type: {
                            name: 'boolean',
                            structure: {},
                        },
                    },
                    {
                        customDescription: 'some alternative custom function description',
                        description: 'Callback when a link is clicked',
                        hidden: true,
                        isRequired: true,
                        name: 'onClick',
                        type: {
                            name: 'func',
                            structure: {},
                        },
                    },
                ],
                wrappers: [],
            };
            // when
            return serializeTSComponent_1.serializeTSComponent(component).then((serializedProps) => {
                // then
                expect(serializedProps.result).toEqual(expectedMetadata);
                expect(serializedProps.warnings).toEqual([]);
            });
        });
        it('serializes component with invalid custom names and gives proper warning', () => {
            // given
            const component = getImplementation('ClassWithCorruptedComments');
            const expectedMetadata = {
                defaultExported: true,
                name: 'ClassWithCorruptedComments',
                properties: [
                    {
                        customName: 'duplicatedCustomName',
                        description: '',
                        isRequired: true,
                        name: 'buttonType',
                        type: {
                            name: 'string',
                            structure: {},
                        },
                    },
                    {
                        customName: 'duplicatedCustomName',
                        description: '',
                        isRequired: true,
                        name: 'isDisabled',
                        type: {
                            name: 'boolean',
                            structure: {},
                        },
                    },
                    {
                        customName: 'isDisabled',
                        description: '',
                        isRequired: true,
                        name: 'isDisabledDuplicate',
                        type: {
                            name: 'boolean',
                            structure: {},
                        },
                    },
                ],
                wrappers: [],
            };
            // when
            return serializeTSComponent_1.serializeTSComponent(component).then((serializedProps) => {
                // then
                expect(serializedProps.result).toEqual(expectedMetadata);
                expect(serializedProps.warnings).toEqual([
                    {
                        message: 'Duplicated custom property name ("duplicatedCustomName") for "isDisabled"',
                        sourcePath: component.path,
                    },
                    {
                        message: 'Custom property name ("isDisabled") for "isDisabledDuplicate" matches existing property name',
                        sourcePath: component.path,
                    },
                ]);
            });
        });
        describe('FunctionWithMultilevelNamespaceDeclaration', () => {
            let serialized;
            beforeAll(() => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
                const component = getImplementation('FunctionWithMultilevelNamespaceDeclaration');
                serialized = yield serializeTSComponent_1.serializeTSComponent(component);
            }));
            it('returns correct component name', () => {
                expect(serialized.result.name).toEqual('FunctionWithMultilevelNamespaceDeclaration');
            });
            it('returns annotated namespace value', () => {
                expect(serialized.result.namespace.name).toEqual('Some.Nested.Namespace');
            });
        });
    });
});
function getImplementation(componentName) {
    return {
        framework: 'reactjs',
        lang: 'typescript',
        path: getExampleComponentPath_1.getTypeScriptComponentPath(componentName),
    };
}
exports.getImplementation = getImplementation;
//# sourceMappingURL=serializeTSComponent.test.js.map