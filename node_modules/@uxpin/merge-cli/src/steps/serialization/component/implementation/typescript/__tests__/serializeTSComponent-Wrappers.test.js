"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const ComponentWrapper_1 = require("../../../wrappers/ComponentWrapper");
const serializeTSComponent_1 = require("../serializeTSComponent");
const serializeTSComponent_test_1 = require("./serializeTSComponent.test");
describe('serializeTSComponent-Wrappers', () => {
    describe('when class component with valid wrappers declaration is provided', () => {
        let component;
        let metadata;
        beforeEach(() => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            component = serializeTSComponent_test_1.getImplementation('ClassWithWrappersDeclaration');
            metadata = yield serializeTSComponent_1.serializeTSComponent(component);
        }));
        it('serializes metadata correctly', () => {
            // having
            const expectedMetadata = {
                defaultExported: true,
                name: 'ClassWithWrappersDeclaration',
                properties: [
                    {
                        description: '',
                        isRequired: true,
                        name: 'name',
                        type: { name: 'string', structure: {} },
                    },
                ],
                wrappers: [
                    {
                        name: 'NonResizableWrapper',
                        type: ComponentWrapper_1.ComponentWrapperType.BUILT_IN,
                    },
                    {
                        name: 'SkipContainerWrapper',
                        type: ComponentWrapper_1.ComponentWrapperType.BUILT_IN,
                    },
                ],
            };
            // when
            // then
            expect(metadata.result).toEqual(expectedMetadata);
        });
        it('gives no warnings', () => {
            expect(metadata.warnings).toEqual([]);
        });
    });
    describe('when class component with invalid wrappers declaration is provided', () => {
        let component;
        let metadata;
        beforeEach(() => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            component = serializeTSComponent_test_1.getImplementation('ClassWithInvalidWrappersDeclaration');
            metadata = yield serializeTSComponent_1.serializeTSComponent(component);
        }));
        it('serializes metadata correctly', () => {
            // having
            const expectedMetadata = {
                defaultExported: true,
                name: 'ClassWithWrappersDeclaration',
                properties: [
                    {
                        description: '',
                        isRequired: true,
                        name: 'name',
                        type: { name: 'string', structure: {} },
                    },
                ],
                wrappers: [
                    {
                        name: 'NonResizableWrapper',
                        type: ComponentWrapper_1.ComponentWrapperType.BUILT_IN,
                    },
                ],
            };
            // when
            // then
            expect(metadata.result).toEqual(expectedMetadata);
        });
        it('gives warning with information about invalid wrapper path', () => {
            expect(metadata.warnings).toEqual([
                {
                    message: 'Invalid wrapper path "./invalid/Path/toWrapper.ts"!',
                    sourcePath: expect.stringContaining('ClassWithInvalidWrappersDeclaration.tsx'),
                },
            ]);
        });
    });
});
//# sourceMappingURL=serializeTSComponent-Wrappers.test.js.map