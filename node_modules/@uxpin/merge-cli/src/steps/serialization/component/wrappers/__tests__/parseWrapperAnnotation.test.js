"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ComponentWrapper_1 = require("../ComponentWrapper");
const parseWrapperAnnotation_1 = require("../parseWrapperAnnotation");
describe('parseWrapperAnnotation', () => {
    describe('when empty tag is provided', () => {
        it('should return an empty array', () => {
            // having
            const tag = '';
            // when
            const wrappers = parseWrapperAnnotation_1.parseWrapperAnnotation(tag);
            // then
            expect(wrappers).toEqual([]);
        });
    });
    describe('when invalid tag is provided', () => {
        it('should return an empty array', () => {
            // having
            const tag = '@uxpincomponent';
            // when
            const wrappers = parseWrapperAnnotation_1.parseWrapperAnnotation(tag);
            // then
            expect(wrappers).toEqual([]);
        });
    });
    describe('when tag with single wrapper is provided', () => {
        describe('and it is a built in wrapper', () => {
            it('should return array with this wrapper', () => {
                // having
                const tag = '@uxpinwrappers NonResizableWrapper';
                const expectedWrappers = [{
                        name: 'NonResizableWrapper',
                        type: ComponentWrapper_1.ComponentWrapperType.BUILT_IN,
                    }];
                // when
                const wrappers = parseWrapperAnnotation_1.parseWrapperAnnotation(tag);
                // then
                expect(wrappers).toEqual(expectedWrappers);
            });
        });
        describe('and it is a custom wrapper', () => {
            it('should return array with this wrapper', () => {
                // having
                const tag = '@uxpinwrappers ./path/to/customWrapper';
                const expectedWrappers = [{
                        name: 'customWrapper',
                        path: './path/to/customWrapper',
                        type: ComponentWrapper_1.ComponentWrapperType.CUSTOM,
                    }];
                // when
                const wrappers = parseWrapperAnnotation_1.parseWrapperAnnotation(tag);
                // then
                expect(wrappers).toEqual(expectedWrappers);
            });
        });
    });
    describe('when multiple wrappers are passed', () => {
        describe('in a single line comment', () => {
            it('should return array of wrappers', () => {
                // having
                const tag = '@uxpinwrappers ./path/to/customWrapper, NonResizableWrapper';
                const expectedWrappers = [
                    {
                        name: 'customWrapper',
                        path: './path/to/customWrapper',
                        type: ComponentWrapper_1.ComponentWrapperType.CUSTOM,
                    },
                    {
                        name: 'NonResizableWrapper',
                        type: ComponentWrapper_1.ComponentWrapperType.BUILT_IN,
                    },
                ];
                // when
                const wrappers = parseWrapperAnnotation_1.parseWrapperAnnotation(tag);
                // then
                expect(wrappers).toEqual(expectedWrappers);
            });
        });
        describe('in a multi line comment', () => {
            it('should return array of wrappers', () => {
                // having
                const tag = `@uxpinwrappers
./path/to/customWrapper,
NonResizableWrapper`;
                const expectedWrappers = [
                    {
                        name: 'customWrapper',
                        path: './path/to/customWrapper',
                        type: ComponentWrapper_1.ComponentWrapperType.CUSTOM,
                    },
                    {
                        name: 'NonResizableWrapper',
                        type: ComponentWrapper_1.ComponentWrapperType.BUILT_IN,
                    },
                ];
                // when
                const wrappers = parseWrapperAnnotation_1.parseWrapperAnnotation(tag);
                // then
                expect(wrappers).toEqual(expectedWrappers);
            });
        });
    });
});
//# sourceMappingURL=parseWrapperAnnotation.test.js.map