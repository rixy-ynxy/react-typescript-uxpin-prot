"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const requestPromise = require("request-promise");
const postPushMetadata_1 = require("../postPushMetadata");
jest.mock('request-promise');
const requestPromiseMock = requestPromise;
describe('postPushMetadata', () => {
    const domain = 'https://uxpin.mock';
    const token = 'token';
    const metadata = {
        result: {
            categorizedComponents: [],
            name: 'Library name',
            vcs: {
                branchName: 'master',
                commitHash: '123abc',
            },
        },
        warnings: [],
    };
    beforeEach(() => {
        requestPromiseMock.mockRestore();
    });
    describe('request', () => {
        beforeEach(() => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            // given
            requestPromiseMock.mockImplementation(() => Promise.resolve({}));
            // when
            yield postPushMetadata_1.postPushMetadata(domain, token, metadata);
        }));
        it('should call proper url', () => {
            const [url] = requestPromiseMock.mock.calls[0];
            expect(url).toEqual('https://uxpin.mock/code/v/1.0/push');
        });
        it('should use proper HTTP method', () => {
            const [, options] = requestPromiseMock.mock.calls[0];
            expect(options.method).toEqual('POST');
        });
        it('should use proper auth-token', () => {
            const [, options] = requestPromiseMock.mock.calls[0];
            expect(options.headers['auth-token']).toEqual('token');
        });
        it('should have User-Agent header', () => {
            const [, options] = requestPromiseMock.mock.calls[0];
            expect(options.headers['User-Agent']).toContain('uxpin-merge-cli');
        });
    });
    describe('HTTP 200', () => {
        let response;
        beforeEach(() => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            // given
            requestPromiseMock.mockImplementation(() => Promise.resolve({
                message: 'Design System snapshot has been uploaded successfully',
            }));
            // when
            response = yield postPushMetadata_1.postPushMetadata(domain, token, metadata);
        }));
        it('should return valid response', () => {
            expect(response.message).toContain('successfully');
        });
    });
    describe('HTTP 401', () => {
        beforeEach(() => {
            // given
            requestPromiseMock.mockImplementation(() => {
                return Promise.reject({
                    error: {
                        error: 'Unauthorized',
                        message: 'Incorrect authorization token',
                        statusCode: 401,
                    },
                });
            });
        });
        it('should reject on error', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            try {
                yield postPushMetadata_1.postPushMetadata(domain, token, metadata);
            }
            catch (error) {
                expect(error).toEqual({
                    error: 'Unauthorized',
                    message: 'Incorrect authorization token',
                    statusCode: 401,
                    url: 'https://uxpin.mock/code/v/1.0/push',
                });
            }
        }));
    });
});
//# sourceMappingURL=postPushMetadata.test.js.map