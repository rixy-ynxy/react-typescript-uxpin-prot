"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const path_1 = require("path");
const requestPromise = require("request-promise");
const postUploadBundle_1 = require("../postUploadBundle");
jest.mock('request-promise');
const requestPromiseMock = requestPromise;
describe('postUploadBundle', () => {
    const domain = 'https://uxpin.mock';
    const token = 'token';
    const path = path_1.resolve(__dirname, './postUploadBundle.test.ts');
    const commitHash = '123abc';
    beforeEach(() => {
        requestPromiseMock.mockRestore();
    });
    describe('request', () => {
        beforeEach(() => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            // given
            requestPromiseMock.mockImplementation(() => Promise.resolve({ url: 'https://s3.mock/bundle.js' }));
            // when
            yield postUploadBundle_1.postUploadBundle(domain, token, commitHash, path);
        }));
        it('should call proper url', () => {
            const [url] = requestPromiseMock.mock.calls[0];
            expect(url).toEqual('https://uxpin.mock/code/v/1.0/push/bundle');
        });
        it('should use proper HTTP method', () => {
            const [, options] = requestPromiseMock.mock.calls[0];
            expect(options.method).toEqual('POST');
        });
        it('should use proper auth-token', () => {
            const [, options] = requestPromiseMock.mock.calls[0];
            expect(options.headers['auth-token']).toEqual('token');
        });
        it('should have User-Agent header', () => {
            const [, options] = requestPromiseMock.mock.calls[0];
            expect(options.headers['User-Agent']).toContain('uxpin-merge-cli');
        });
    });
    describe('HTTP 200', () => {
        let response;
        beforeEach(() => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            // given
            requestPromiseMock.mockImplementation(() => Promise.resolve({ url: 'https://s3.mock/bundle.js' }));
            // when
            response = yield postUploadBundle_1.postUploadBundle(domain, token, commitHash, path);
        }));
        it('should return valid response', () => {
            expect(response.url).toEqual('https://s3.mock/bundle.js');
        });
    });
    describe('HTTP 401', () => {
        beforeEach(() => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            // given
            requestPromiseMock.mockImplementation(() => {
                return Promise.reject({
                    error: {
                        error: 'Unauthorized',
                        message: 'Incorrect authorization token',
                        statusCode: 401,
                    },
                });
            });
        }));
        it('should reject on error', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            try {
                yield postUploadBundle_1.postUploadBundle(domain, token, commitHash, path);
            }
            catch (error) {
                expect(error).toEqual({
                    error: 'Unauthorized',
                    message: 'Incorrect authorization token',
                    statusCode: 401,
                    url: 'https://uxpin.mock/code/v/1.0/push/bundle',
                });
            }
        }));
    });
});
//# sourceMappingURL=postUploadBundle.test.js.map