"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const react_docgen_1 = require("react-docgen");
const getManyProps_1 = require("./getManyProps");
const isPathNodeType_1 = require("./isPathNodeType");
const isPropTypesExpression_1 = require("./isPropTypesExpression");
const NodePathTypes_1 = require("./Nodes/NodePathTypes");
const resolveToValue_1 = require("./resolveToValue");
var NodeOperator;
(function (NodeOperator) {
    NodeOperator["EQUALITY"] = "=";
})(NodeOperator = exports.NodeOperator || (exports.NodeOperator = {}));
function getParser(type) {
    switch (type) {
        case NodePathTypes_1.NodePathType.MEMBER_EXPERSSION:
            return memberExpressionParser;
        case NodePathTypes_1.NodePathType.OBJECT_EXPRESSION:
            return objectExpressionParser;
        case NodePathTypes_1.NodePathType.PROPERTY:
            return propertyParser;
        default:
            return () => undefined;
    }
}
function memberExpressionParser(path, context) {
    if (isPropTypesExpression_1.isPropTypesExpression(path)) {
        getManyProps_1.getManyProps(path, ['object', 'property'])
            .filter((innerPath) => innerPath.node.type !== NodePathTypes_1.NodePathType.IDENTIFIER)
            .forEach((innerPath) => parsePath(innerPath, context));
        return;
    }
    const objectPath = path.get('object');
    if (objectPath && !isPathNodeType_1.isPathNodeType(objectPath, NodePathTypes_1.NodePathType.CALL_EXPRESSION)) {
        const resolved = resolveToValue_1.resolveToValue(objectPath, context);
        if (isPathNodeType_1.isPathNodeType(resolved, NodePathTypes_1.NodePathType.CALL_EXPRESSION)
            || isPathNodeType_1.isPathNodeType(resolved, NodePathTypes_1.NodePathType.MEMBER_EXPERSSION)
            || isPathNodeType_1.isPathNodeType(resolved, NodePathTypes_1.NodePathType.IDENTIFIER)) {
            return;
        }
        const name = react_docgen_1.utils.getNameOrValue(path.get('property'));
        const memberValuePath = react_docgen_1.utils.getMemberValuePath(resolved, name);
        if (!memberValuePath) {
            return;
        }
        parsePath(memberValuePath, context);
    }
}
function objectExpressionParser(path, context) {
    path.get('properties').each((propertyPath) => {
        parsePath(propertyPath, context);
    });
}
function propertyParser(path, context) {
    const name = react_docgen_1.utils.getPropertyName(path);
    if (!name) {
        return;
    }
    const valuePath = path.get('value');
    const value = resolveToValue_1.resolveToValue(valuePath, context);
    parsePath(value, context);
    const type = react_docgen_1.utils.getPropType(value);
    if (!type) {
        return;
    }
    // Yeah, we mutate current property description to update the value
    const propDescription = context.docsDescriptor(name);
    propDescription.type = type;
}
function parsePath(path, context) {
    const parser = getParser(path.node.type);
    parser(path, context);
    return {};
}
exports.parsePath = parsePath;
//# sourceMappingURL=parsePath.js.map