"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ast_types_1 = require("ast-types");
const react_docgen_1 = require("react-docgen");
const getSourceSync_1 = require("./fs/getSourceSync");
const findImportDeclaration_1 = require("./Nodes/imports/findImportDeclaration");
const getImportDeclarationFilePath_1 = require("./Nodes/imports/getImportDeclarationFilePath");
const getImportSpecifier_1 = require("./Nodes/imports/getImportSpecifier");
const NodePathTypes_1 = require("./Nodes/NodePathTypes");
// tslint:disable-next-line:no-var-requires
const babelParser = require('react-docgen/dist/babelParser').default;
function resolvePropTypesExpression(path, context) {
    const propValue = react_docgen_1.utils.getPropType(path);
    if (propValue.name === 'enum') {
        return resolveEnumPropTypeValue(propValue, path, context);
    }
    return path;
}
exports.resolvePropTypesExpression = resolvePropTypesExpression;
function resolveEnumPropTypeValue(propType, path, context) {
    const bindings = path.scope.getBindings();
    const valueBindings = bindings[propType.value];
    const valueBinding = valueBindings ? valueBindings[0] : undefined;
    if (!valueBindings || !valueBinding) {
        return path;
    }
    const importDeclaration = findImportDeclaration_1.findImportDeclaration(valueBinding, context);
    if (!importDeclaration) {
        return path;
    }
    const filePath = getImportDeclarationFilePath_1.getImportDeclarationFilePath(importDeclaration, context);
    if (!filePath) {
        return path;
    }
    const result = babelParser().parse(getSourceSync_1.getSourceSync(filePath));
    const declaration = findExternalVariableDeclaration(result, importDeclaration, valueBinding);
    if (!declaration) {
        return path;
    }
    const members = react_docgen_1.utils.getMembers(path);
    const oneOfMember = members.find(({ path: memberPath }) => {
        return memberPath.node.name === 'oneOf';
    });
    if (!oneOfMember || !oneOfMember.argumentsPath) {
        return path;
    }
    // Replace NodePath with variable identifier to actual value of the variable
    oneOfMember.argumentsPath.get(0).replace(declaration.get('declarations').get(0).node);
    return path;
}
function findExternalVariableDeclaration(path, importDeclaration, binding) {
    const variableName = react_docgen_1.utils.getNameOrValue(binding);
    const specifier = getImportSpecifier_1.getImportSpecifier(importDeclaration, variableName);
    if (!specifier) {
        return;
    }
    const isDefaultImport = specifier.type === NodePathTypes_1.NodePathType.IMPORT_DEFAULT_SPECIFIER;
    let resultPath;
    ast_types_1.visit(path, {
        visitExportDefaultDeclaration(exportPath) {
            if (resultPath || !isDefaultImport) {
                return false;
            }
            const resolved = react_docgen_1.utils.resolveExportDeclaration(exportPath);
            if (resolved[0]) {
                resultPath = resolved[0];
            }
            // tslint:disable-next-line:no-invalid-this
            this.traverse(exportPath);
        },
        visitVariableDeclaration(variablePath) {
            // Return false to stop traversing
            if (resultPath || isDefaultImport) {
                return false;
            }
            const declarations = variablePath.get('declarations').value;
            const hasDeclaration = declarations.some((declaration) => {
                return !!declaration.id && declaration.id.name === variableName;
            });
            if (hasDeclaration) {
                resultPath = variablePath;
            }
            // tslint:disable-next-line:no-invalid-this
            this.traverse(variablePath);
            return;
        },
    });
    return resultPath;
}
//# sourceMappingURL=resolvePropTypesExpression.js.map